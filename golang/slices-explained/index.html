<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slices in a nutshell | yourbasic.org </title>
  <meta name="description" content="All about Go slices.">
  
  <link rel="stylesheet" href="/style.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="icon" type="image/png" href="/res/favicon-16x16.png">
  <link rel="icon" type="image/png" href="/res/favicon-32x32.png">
  <link rel="icon" type="image/png" href="/res/favicon-96x96.png">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113104149-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113104149-1');
  </script>

</head>

<body>
<header>
  <nav>
    <ul>
      <li><a href="/about/">About</a></li>
      <li><a href="/" title="Your Basic Homepage">Home</a></li>
      <li><a href="/algorithms/">Algorithms</a></li>
      <li><a href="/golang/">Go</a></li>
    </ul>
  </nav>
</header>

<main>
<article>
<h1>Slices in a nutshell</h1>
<div class="tagline">yourbasic.org</div>


<p class="lead">A slice doesn't store any data,
it just describes a section of an underlying&nbsp;array.</p>

<!-- CC0: https://pixabay.com/en/orange-food-juicy-fruit-188082/ -->

<p><img src="/golang/orange.jpg" alt="A sliced orange"></p>

<p>A slice describes a <strong>section</strong> of an <strong>underlying array</strong>.</p>

<ul>
<li>When you change an element of a slice, you modify the corresponding element of its underlying array,
and other slices that share the same underlying array will see the change.</li>
<li>A slice can grow and shrink within the bounds of the underlying array.</li>
<li>Slices are indexed in the usual way: the expression <code>s[i]</code> accesses
the <code>i</code>th element, starting from&nbsp;zero.</li>
</ul>

<pre><code>var s []int <span class="comment">// s == nil, len(s) == 0, cap(s) == 0</span>
s1 := []string{"foo", "bar"}
s2 := make([]int, 2)          <span class="comment">// same as []int{0, 0}</span>
s3 := make([]int, 2, 4)       <span class="comment">// same as new([4]int)[:2]</span>
fmt.Println(len(s3), cap(s3)) <span class="comment">// 2 4</span></code></pre>

<ul>
<li>The default <strong>zero value</strong> of a slice is <code>nil</code>.
The functions <code>len</code>, <code>cap</code> and <code>append</code>
all regard <code>nil</code> as an empty slice with 0&nbsp;capacity.</li>
<li>You create a slice either by a <strong>slice literal</strong> or
a call to the <a href="https://golang.org/pkg/builtin/#make"><code>make</code></a> function,
which takes the <strong>length</strong> and an optional <strong>capacity</strong> as arguments.</li>
<li>The built-in <a href="https://golang.org/pkg/builtin/#len"><code>len</code></a> and
<a href="https://golang.org/pkg/builtin/#cap"><code>cap</code></a> functions
retrieve the length and capacity.</li>
</ul>

<h2 id="slicing">Slicing</h2>

<p>You can also create a slice by slicing an existing array or slice.</p>

<ul>
<li>A slice is formed by specifying a low&nbsp;bound and a high&nbsp;bound: <code>a[low:high]</code>.
This selects a half-open range which includes the first element, but excludes the last&nbsp;one.</li>
<li>You may omit the high or low bounds to use their defaults instead.
The default is zero for the low bound and the length of the slice for the high bound.</li>
</ul>

<pre><code>a := [...]int{0, 1, 2, 3}
s := a[1:3] <span class="comment">// s == []int{1, 2}        cap(s) == 3</span>
s = a[:2]   <span class="comment">// s == []int{0, 1}        cap(s) == 4</span>
s = a[2:]   <span class="comment">// s == []int{2, 3}        cap(s) == 2</span>
s = a[:]    <span class="comment">// s == []int{0, 1, 2, 3}  cap(s) == 4</span>
</code></pre>

<p>When you slice a slice, the indexes are relative to the slice itself,
not to the backing array.</p>

<ul>
<li>The high bound is not bound by the slice&rsquo;s length, but by it&rsquo;s capacity,
which means you can extend the length of the slice.</li>
<li>Trying to extend beyond the capacity causes a panic.</li>
</ul>

<pre><code>s := []int{0, 1, 2, 3, 4}
s = s[1:4] <span class="comment">// s == []int{1, 2, 3}</span>
s = s[1:2] <span class="comment">// s == []int{2}       (index relative to slice, not array)</span>
s = s[:3]  <span class="comment">// s == []int{2, 3, 4} (extend length)</span>
</code></pre>

<h2 id="iteration">Iteration</h2>

<pre><code>s := []string{"Foo", "Bar"}
<b>for i, v := range s</b> {
    fmt.Println(i, v)
}</code></pre>

<pre><code>0 Foo
1 Bar
</code></pre>

<ul>
<li>The range expression, <code>s</code>, is <strong>evaluated once</strong> before beginning the loop.</li>
<li>The iteration values are assigned to the respective iteration variables, <code>i</code> and <code>v</code>,
<strong>as in an assignment statement</strong>.</li>
<li>The second iteration variable is optional.</li>
<li>If the slice is <code>nil</code>, the number of iterations is&nbsp;0.</li>
</ul>

<h2 id="append-and-copy">Append and copy</h2>

<ul>
<li>The <code>append</code> function appends elements to a slice.
It will <strong>automatically allocate</strong> a larger backing array if the capacity is exceeded.
See <a href="/golang/copy-explained/">Append&nbsp;function</a>.</li>
<li>The <code>copy</code> function copies elements
into a destination slice <code>dst</code> from a source slice <code>src</code>.
The number of elements copied is the <strong>minimum</strong> of <code>len(dst)</code> and <code>len(src)</code>.
See <a href="/golang/copy-explained/">Copy&nbsp;function</a>.
<br /></li>
</ul>

<h2 id="more-nutshells">More nutshells</h2>

<div><a href="/golang/maps-explained/"><img src="/golang/Schlagwortkatalog-thumb.jpg" title="Maps in a nutshell"></a></div>

<p style="margin-top:0; margin-bottom:2em;"><a href="/golang/maps-explained/">Maps in a&nbsp;nutshell</a></p>

<div><a href="/golang/for-loop/"><img src="/golang/hula-hoop-thumb.jpg" title="For loops in a nutshell"></a></div>

<p style="margin-top:0; margin-bottom:2em;"><a href="/golang/for-loop/">For loops in a&nbsp;nutshell</a></p>

<p><b>Share this article:</b>
    <a href="https://twitter.com/share?url=http%3a%2f%2fyourbasic.org%2fgolang%2fslices-explained%2f&amp;text=Slices%20in%20a%20nutshell">Twitter</a>&nbsp;|
<a href="https://www.facebook.com/sharer.php?u=http%3a%2f%2fyourbasic.org%2fgolang%2fslices-explained%2f">Facebook</a>&nbsp;|
<a href="https://www.reddit.com/submit?url=http%3a%2f%2fyourbasic.org%2fgolang%2fslices-explained%2f&amp;title=Slices%20in%20a%20nutshell">Reddit</a></p>

</article>
<aside>

    
  <h2>Related</h2>

  <div class="reference">
    <a href="/golang/append-explained/">Append function</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="/golang/copy-explained/">Copy function</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="/golang/find-search-contains-slice/">Find an element in a slice</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="/golang/delete-element-slice/">Delete an element from a slice</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="/golang/clear-slice/">Clear a slice</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="/golang/compare-slices/">Compare slices (arrays)</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="https://blog.golang.org/go-slices-usage-and-internals">Go Slices: usage and internals</a><br />
    <span class="source">The Go Blog</span>
    <span class="author"></span>
  </div>

<h2>New in Go 1.10</h2>
  <ul class="none">
    <li><a href="/golang/build-append-concatenate-strings-efficiently/">Build and concatenate strings efficiently</a></li>

    <li><a href="/golang/round-float-to-int/">Round float to integer value</a></li>

    <li><a href="/golang/shuffle-slice-array/">Shuffle a slice or array</a></li>

  </ul>

  <h2>Top Go articles</h2>
  <ul class="none">
  
    <li><a href="/golang/gotcha/">Go gotcha</a></li>

    <li><a href="/golang/string-functions-reference-cheat-sheet/">String handling cheat sheet</a></li>

    <li><a href="/golang/slices-explained/">Slices in a nutshell</a></li>

    <li><a href="/golang/maps-explained/">Maps in a nutshell</a></li>

    <li><a href="/golang/concurrent-programming/">Concurrent programming</a></li>

  </ul>
  <p><a href="/golang/"><strong>See all 198 Go articles</strong></a></p>
</aside>
</main>

<footer>
  This work is licensed under&nbsp;a&nbsp;<a rel="license" alt="CC BY 3.0"
  href="http://creativecommons.org/licenses/by/3.0/"><span
  style="font-size:smaller;">CC&nbsp;BY&nbsp;3.0</span>&nbsp;license</a>.
</footer>
</body>
</html>
