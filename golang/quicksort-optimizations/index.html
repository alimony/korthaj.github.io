<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Top 3 Quicksort optimizations - yourbasic.org/golang </title>
  <meta name="description" content="CODE EXAMPLE For a fast implementation of Quicksort choose a good pivot, use 3-way partitioning, and switch to insertion sort.">
  
  <link rel="stylesheet" href="/style.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="icon" type="image/png" href="/res/favicon-16x16.png">
  <link rel="icon" type="image/png" href="/res/favicon-32x32.png">
  <link rel="icon" type="image/png" href="/res/favicon-96x96.png">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113104149-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113104149-1');
  </script>

  <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://yourbasic.org/golang/quicksort-optimizations/"
  },
  "headline": "Top 3 Quicksort optimizations",
  "image": [
    "http://yourbasic.org/golang/divide-conquer.jpg"
   ],
  "datePublished": "2018-02-28T00:00:00&#43;0000",
  "dateModified": "2018-02-28T00:00:00&#43;0000",
  "author": {
    "@type": "Person",
    "name": "Stefan Nilsson"
  },
   "publisher": {
    "@type": "Organization",
    "name": "yourbasic.org",
    "logo": {
      "@type": "ImageObject",
      "url": "http://yourbasic.org/res/favicon-96x96.png"
    }
  },
  "description": "CODE EXAMPLE For a fast implementation of Quicksort choose a good pivot, use 3-way partitioning, and switch to insertion sort."
}
</script>

<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Top 3 Quicksort optimizations">
<meta property="og:description" content="CODE EXAMPLE For a fast implementation of Quicksort choose a good pivot, use 3-way partitioning, and switch to insertion sort.">
<meta property="og:url" content="http://yourbasic.org/golang/quicksort-optimizations/">
<meta property="og:image" content="http://yourbasic.org/golang/divide-conquer.jpg">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Top 3 Quicksort optimizations">
<meta name="twitter:description" content="CODE EXAMPLE For a fast implementation of Quicksort choose a good pivot, use 3-way partitioning, and switch to insertion sort.">
<meta name="twitter:site" content="@yourbasic_org">
<meta name="twitter:image" content="http://yourbasic.org/golang/divide-conquer.jpg">


</head>

<body>
<header>
  <nav>
    <ul>
      <li><a href="/about/">About</a></li>
      <li><a href="/">Home</a></li>
      <li><a href="/algorithms/">Algorithms</a></li>
      <li class="here"><a href="/golang/">Go</a></li>
    </ul>
  </nav>
</header>

<main>
<article>
<h1>Top 3 Quicksort optimizations</h1>
<div class="tagline">yourbasic.org/golang</div>


<!-- CC BY 2.0:https://www.flickr.com/photos/nicola_s/20141007433 -->

<div><img src="/golang/divide-conquer.jpg" class="extra-content" style="float: right; margin: 20px 0 0 20px;" alt="Quicksort is a divide-and-conquer algorithm"></div>

<p class="lead">Most Quicksort optimi&shy;zations give only small improve&shy;ments.
Here&nbsp;are three that can make a&nbsp;real differ&shy;ence.</p>

<ul>
<li>Choose a good pivot.</li>
<li>Use 3-way partitioning.</li>
<li>Switch to a simpler algorithm for short sublists.</li>
</ul>

<h2 id="algorithm-overview">Algorithm overview</h2>

<ul>
<li>Pick an element <code>p</code>, called a pivot, from the list.</li>
<li>Partition the list so that

<ul>
<li>all elements less than <code>p</code> come first,</li>
<li>all elements greater than <code>p</code> come last,</li>
<li>elements equal to <code>p</code> go into the middle.</li>
</ul></li>
<li>Recursively apply the above steps to the sublists of small and large elements.</li>
<li>For short sublists, use a simpler sorting algorithm.</li>
</ul>

<pre><code>//  Quicksort sorts the elements of v in ascending order.
func Quicksort(v []int) {
    if len(v) < 20 {
        InsertionSort(v)
        return
    }
    p := Pivot(v)
    low, high := Partition(v, p)
    Quicksort(v[:low])
    Quicksort(v[high:])
}</code></pre>

<p>With some ingenuity this algorithm can be implemented to run very fast.</p>

<p>If we assume that the partition is done in linear time (which is possible to achieve)
and that the list is divided exactly in the middle (which is unlikely),
the expected time to sort a list of <i>n</i>&nbsp;elements
is&nbsp;<i>O</i>(<i>n</i>&nbsp;log&nbsp;<i>n</i>).</p>

<p>Unfortunately the worst case is Î¸(<i>n</i><sup>2</sup>),
but this case is rare if the pivot is chosen carefully.</p>

<h2 id="pivot">Pivot</h2>

<p>Choosing a suitable pivot <code>p</code> is a balancing act:</p>

<ul>
<li>if we are sloppy, the partition can be lopsided;</li>
<li>if we compute <code>p</code> as the median of all elements,
this step may dominate the running time.</li>
</ul>

<p>A simple solution is to choose <code>p</code> as a random list element.
The expected number of comparisons for sorting a list of elements, all different,
then becomes 1.4&#8202;<i>n</i>&nbsp;log&nbsp;<i>n</i>. Also, with a good random source, this choice virtually
eliminates the risk of quadratic performance.</p>

<p>Another common choice is <code>p := Median(v[0], v[len(v)/2], v[len(v)-1])</code>,
but this can be risky. In fact, combining this pivot with the partion algorithm
in the next section gives very poor performance when sorting an already sorted list.</p>

<p>A more robust solution is to combine the two ideas and use
the median of three random elements.
With this strategy, the expected number of comparisons becomes
1.2&#8202;<i>n</i>&nbsp;log&nbsp;<i>n</i>.</p>

<pre><code>func Pivot(v []int) int {
	n := len(v)
	return Median(v[rand.Intn(n)],
		v[rand.Intn(n)],
		v[rand.Intn(n)])
}

func Median(a, b, c int) int {
	if a &lt; b {
		switch {
		case b &lt; c:
			return b
		case a &lt; c:
			return c
		default:
			return a
		}
	}
	switch {
	case a &lt; c:
		return a
	case b &lt; c:
		return c
	default:
		return b
	}
}
</code></pre>

<h2 id="3-way-partition">3-way partition</h2>

<p>This 3-way partition algorithm handles input with many replicated elements gracefully,
a case where the standard 2-way partition can run into troubles.
A well-chosen <a href="/algorithms/loop-invariants-explained/">loop invariant</a>
is vital if we want to untangle this intricate piece of code.</p>

<pre><code>// Partition reorders the elements of v so that:
// - all elements in v[:low] are less than p,
// - all elements in v[low:high] are equal to p,
// - all elements in v[high:] are greater than p.
func Partition(v []int, p int) (low, high int) {
	low, high = 0, len(v)
	for mid := 0; mid &lt; high; {
		// Invariant:
		//  - v[:low] &lt; p
		//  - v[low:mid] = p
		//  - v[mid:high] are unknown
		//  - v[high:] &gt; p
		//
		//         &lt; p       = p        unknown       &gt; p
		//     -----------------------------------------------
		// v: |          |          |a            |           |
		//     -----------------------------------------------
		//                ^          ^             ^
		//               low        mid           high
		switch a := v[mid]; {
		case a &lt; p:
			v[mid] = v[low]
			v[low] = a
			low++
			mid++
		case a == p:
			mid++
		default: // a &gt; p
			v[mid] = v[high-1]
			v[high-1] = a
			high--
		}
	}
	return
}
</code></pre>

<p>It&rsquo;s easy to see that the algorithm runs in linear time:
the distance between <code>mid</code> and <code>high</code> decreases in every loop,
either because <code>mid</code> increases or because <code>high</code> decreases.</p>

<h2 id="combining-algorithms">Combining algorithms</h2>

<p>Experience shows that Quicksort is the fastest comparison-based sorting algorithm
for many types of data. However, in some cases there are better options.
<a href="/algorithms/insertion-sort/">Insertion sort</a>, which has quadratic worst-case time, tends to be
faster for small lists.</p>

<p>By combining the two algorithms we get the best of two worlds:</p>

<ul>
<li>use Quicksort to sort long sublists,</li>
<li>and Insertion sort otherwise.</li>
</ul>

<p>The optimal break point depends on many factors (how the code is written,
the nature of the data, hardware characteristics)
and has to be found experimentally. Luckily the choice is seldom critical:
break points between 10 and 100 tend to work well.</p>

<pre><code>func InsertionSort(v []int) {
	for j := 1; j &lt; len(v); j++ {
		// Invariant: v[:j] contains the same elements as
		// the original slice v[:j], but in sorted order.
		key := v[j]
		i := j - 1
		for i &gt;= 0 &amp;&amp; v[i] &gt; key {
			v[i+1] = v[i]
			i--
		}
		v[i+1] = key
	}
}
</code></pre>

<h3 id="further-reading">Further reading</h3>

<div><a href="/algorithms/fastest-sorting-algorithm/"><img src="/algorithms/sorted-thumb.jpg" title="The fastest sorting algorithm?"></a></div>

<p style="margin-top:0;">See <a href="/algorithms/fastest-sorting-algorithm/">The fastest sorting algorithm?</a> for an <i>O</i>(<i>n</i>&nbsp;log&nbsp;log&nbsp;<i>n</i>) time sorting algorithm.</p>

<p style="margin-top:2em;"><span style="position:relative;bottom:12px;"><b>Share<span class="extra-content"> this page</span>:</b></span>&nbsp;&nbsp;
<a href="https://twitter.com/share?url=http%3a%2f%2fyourbasic.org%2fgolang%2fquicksort-optimizations%2f&amp;text=Top%203%20Quicksort%20optimizations&amp;via=yourbasic%5forg" title="Share on Twitter"><img width="40px" src="/res/twitter-logo.svg"></a>&nbsp;&nbsp;
<a href="https://www.facebook.com/sharer.php?u=http%3a%2f%2fyourbasic.org%2fgolang%2fquicksort-optimizations%2f" title="Share on Facebook"><img width="36px" src="/res/facebook-logo.svg"></a>&nbsp;&nbsp;&nbsp;
<a href="https://www.reddit.com/submit?url=http%3a%2f%2fyourbasic.org%2fgolang%2fquicksort-optimizations%2f&amp;title=Top%203%20Quicksort%20optimizations" title="Share on Reddit"><img width="36px" src="/res/reddit-logo.svg"></a>&nbsp;&nbsp;&nbsp;
<span style="position:relative;bottom:2px;" class="small-content"><a href="mailto:?subject=Top%203%20Quicksort%20optimizations&body=http%3a%2f%2fyourbasic.org%2fgolang%2fquicksort-optimizations%2f" title="Share by mail"><img width="30px" src="/res/mail-logo.svg"></a></span></p>


</article>
<aside>

    
  <h2>Related</h2>

  <div class="reference">
    <a href="/algorithms/fastest-sorting-algorithm/">The fastest sorting algorithm?</a>
    <div class="desc">Which sorting algorithm is the fastest? If you count the number of operations needed to sort integer numbers, there is a clear winner. You can sort n integers in O(n log log n) time.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/algorithms/insertion-sort/">Insertion sort</a>
    <div class="desc">Insertion sort is a simple algorithm with quadratic worst-case running time. It can outperform more complicated algorithms for short lists and lists that are almost sorted.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/algorithms/loop-invariants-explained/">Loop invariants can give you coding superpowers</a>
    <div class="desc">Loop invariants are a simple yet powerful tool for designing, testing, modifying, documenting and proving code correct.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <h2>Follow on Twitter</h2>
  <ul class="none">
    <li><span><a href="https://twitter.com/yourbasic_org">
    <img width="22px" src="/res/twitter-logo.svg" title="Follow yourbasic.org on Twitter"></a></span>
    <a href="https://twitter.com/yourbasic_org">One useful golang fact per&nbsp;day</a></li>
  </ul>


  <h2>Most Read</h2>
  <ul class="none">
  
    <li><a href="/golang/gotcha/">Go gotcha: newbie or ninja?</a></li>

    <li><a href="/golang/blueprint/">Go blueprints: code for common tasks</a></li>

    <li><a href="/golang/build-append-concatenate-strings-efficiently/">How to build strings efficiently</a></li>

    <li><a href="/golang/concurrent-programming/">Concurrent programming</a></li>

    <li><a href="/golang/inheritance-object-oriented/">Inheritance and OOP: Go one better</a></li>

  </ul>
  
  <p><a href="/golang/"><strong>See all 196 Go articles</strong></a></p>

</aside>
</main>

<footer>
  This work is licensed under&nbsp;a&nbsp;<a rel="license" alt="CC BY 3.0"
  href="http://creativecommons.org/licenses/by/3.0/"><span
  style="font-size:smaller;">CC&nbsp;BY&nbsp;3.0</span>&nbsp;license</a>.
</footer>
</body>
</html>
