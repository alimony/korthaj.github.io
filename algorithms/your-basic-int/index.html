<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Your basic int: a most powerful data type | yourbasic.org </title>
  <meta name="description" content="The int data type is generic, effective, simple and efficient. It can represent any digital data. Furthermore, an int can point into any type of array. That’s as generic as it gets.">
  
  <link rel="stylesheet" href="/style.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="icon" type="image/png" href="/res/favicon-16x16.png">
  <link rel="icon" type="image/png" href="/res/favicon-32x32.png">
  <link rel="icon" type="image/png" href="/res/favicon-96x96.png">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113104149-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113104149-1');
  </script>

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://yourbasic.org/algorithms/your-basic-int/"
  },
  "headline": "Your basic int: a most powerful data type",
  "image": [
    "http://yourbasic.org/algorithms/eratosthenes.png"
   ],
  "datePublished": "2018-01-26T00:00:00&#43;0000",
  "dateModified": "2018-01-26T00:00:00&#43;0000",
  "author": {
    "@type": "Person",
    "name": "Stefan Nilsson"
  },
   "publisher": {
    "@type": "Organization",
    "name": "yourbasic.org",
    "logo": {
      "@type": "ImageObject",
      "url": "http://yourbasic.org/res/favicon-96x96.png"
    }
  },
  "description": "The int data type is generic, effective, simple and efficient. It can represent any digital data. Furthermore, an int can point into any type of array. That’s as generic as it gets."
}
</script>

</head>

<body>
<header>
  <nav>
    <ul>
      <li><a href="/about/">About</a></li>
      <li><a href="/">Home</a></li>
      <li><a href="/algorithms/">Algorithms</a></li>
      <li><a href="/golang/">Go</a></li>
    </ul>
  </nav>
</header>

<main>
<article>
<h1>Your basic int: a most powerful data type</h1>
<div class="tagline">yourbasic.org</div>


<div><img src="/algorithms/z.png" width="80px" style="float:right; margin-top:20px;"></div>

<p class="lead">The int data type is generic, effective, simple and efficient.</p>

<ul class="toc">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#generic-graph-data">Generic graph data</a></li>
<li><a href="#effective-searching-and-sorting">Effective searching and sorting</a></li>
<li><a href="#simple-sets">Simple sets</a></li>
<li><a href="#efficient-filtering">Efficient filtering</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Every kid can spot an <a href="https://en.wikipedia.org/wiki/Integer">integer number</a>,
and every programmer is familiar with the <a href="https://en.wikipedia.org/wiki/Integer_(computer_science)">int data type</a>.
Still we frequently forget how powerful an integer can be.</p>

<ul>
<li><strong>Generic</strong><br />
An <code>int</code> or <code>[]int</code> is a bit pattern that can represent any digital data.
Furthermore, an <code>int</code> can point into any type of array.
That&rsquo;s as generic as it gets.</li>
<li><strong>Effective</strong><br />
With an <code>int</code> you have all of basic mathematics at your finger tips,
and boolean algebra, implemented with bit-level parallelism, to boot.</li>
<li><strong>Simple</strong><br />
Not really, but we&rsquo;ve used arithmetic since childhood so it feels that way.
Familiarity breeds both simplicity and contempt.</li>
<li><strong>Efficient</strong><br />
An <code>int</code> fits inside a register sitting on the main datapath of the CPU,
and an <code>[]int</code> is the main focus of hardware memory optimization.
It doesn&rsquo;t get much faster or more efficient than that.</li>
</ul>

<h3 id="resources">Resources</h3>

<p>This text comes with four Go example libraries:</p>

<ul>
<li><a href="https://github.com/yourbasic/bit">bit</a>
contains a bit array and some bit-twiddling functions,</li>
<li><a href="https://github.com/yourbasic/bloom">bloom</a>
is a Bloom filter, a probabilistic set data structure,</li>
<li><a href="https://github.com/yourbasic/graph">graph</a>
is a library of basic graph algorithms, and</li>
<li><a href="https://github.com/yourbasic/radix">radix</a>
is a string sorting algorithm implemented with MSD radix sort.</li>
</ul>

<h2 id="generic-graph-data">Generic graph data</h2>

<p><img src="/algorithms/graph.png" alt="Graph" /></p>

<p><strong>Cubical graph with vertex colors</strong> <!-- *image from [Wikipedia][wikicube].* --></p>

<p>Since graphs are used to model countless types of relations and processes
in varied kinds of systems and settings, there is no telling what kind of data
a generic graph library will encounter; both vertices and edges can have
labels attached to them. Should we use parametric polymorphism or perhaps a pointer
to the top of a type hierarchy?</p>

<p>It&rsquo;s easy to forget that an integer may be the preferred choice.
Here is a solution from the <a href="https://github.com/yourbasic/graph">graph</a> package.</p>

<pre><code>All algorithms operate on directed graphs with
a fixed number of vertices, labeled from 0 to n-1,
and edges with integer cost.
</code></pre>

<p>Since vertices are represented by integers, it&rsquo;s easy to add any kind of
vertex data on the side.</p>

<h3 id="breadth-first-search">Breadth-first search</h3>

<p>For example, this generic implementation of breadth-first search uses
an array of booleans to keep track of which vertices have been visited.</p>

<pre><code class="language-go">// BFS traverses g in breadth-first order starting at v.
// When the algorithm follows an edge (v, w) and finds
// a previously unvisited vertex w, it calls do(v, w, c)
// with c equal to the cost of the edge (v, w).
func BFS(g Iterator, v int, do func(v, w int, c int64)) {
	visited := make([]bool, g.Order())
	visited[v] = true
	for queue := []int{v}; len(queue) &gt; 0; {
		v := queue[0]
		queue = queue[1:]
		g.Visit(v, func(w int, c int64) (skip bool) {
			if visited[w] {
				return
			}
			do(v, w, c)
			visited[w] = true
			queue = append(queue, w)
			return
		})
	}
}
</code></pre>

<h2 id="effective-searching-and-sorting">Effective searching and sorting</h2>

<p>Some of the most effective search and sort algorithms are implemented
by bit manipulation done with <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise integer operators</a>.
These operators operate, often in parallel, on the single bits of an integer.
Even though they don&rsquo;t form a Turing-complete set of operations,
they can still be surprisingly effective.</p>

<p>The standard set of bitwise operators, found in almost every CPU,
includes the bitwise <code>not</code>, <code>and</code>, <code>or</code> and <code>xor</code> instructions; plus
a collection of <code>shift</code> and <code>rotate</code> instructions. A bit count instruction,
often known as <code>popcnt</code>, is also quite common.</p>

<h3 id="needles-in-huge-haystacks">Needles in huge haystacks</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two integers,
the number of positions at which the corresponding bits are different,
is an effective way to estimate similarity. It can be computed
using just one <code>xor</code> and one <code>popcnt</code> instruction.</p>

<p><img src="/algorithms/hamming.png" alt="Hamming distance" /></p>

<p><strong>The Hamming distance</strong> <em>between adjacent vertices
in a cubical graph is one.</em> <!-- image from [Wikipedia][wikihammingpic]. --></p>

<p>Rumor has it that organizations who are sifting through huge amounts of data
prefer to buy CPUs that come with a bit count instruction.
As a case in point, the new Zen microarchitecture from AMD supports
no less than four <code>popcnt</code> instructions per clock cycle.</p>

<h3 id="bit-count">Bit count</h3>

<p>If the CPU doesn&rsquo;t have a native bit count operation, <code>popcnt</code> can still
be implemented quite efficiently using the more common bitwise operators.
Here is a fun code sample from the <a href="https://github.com/yourbasic/bit">bit</a> package.</p>

<pre><code class="language-go">// Count returns the number of nonzero bits in w.
func Count(w uint64) int {
	// “Software Optimization Guide for AMD64 Processors”, Section 8.6.
	const maxw = 1&lt;&lt;64 - 1
	const bpw = 64

	// Compute the count for each 2-bit group.
	// Example using 16-bit word w = 00,01,10,11,00,01,10,11
	// w - (w&gt;&gt;1) &amp; 01,01,01,01,01,01,01,01 = 00,01,01,10,00,01,01,10
	w -= (w &gt;&gt; 1) &amp; (maxw / 3)

	// Add the count of adjacent 2-bit groups and store in 4-bit groups:
	// w &amp; 0011,0011,0011,0011 + w&gt;&gt;2 &amp; 0011,0011,0011,0011 = 0001,0011,0001,0011
	w = w&amp;(maxw/15*3) + (w&gt;&gt;2)&amp;(maxw/15*3)

	// Add the count of adjacent 4-bit groups and store in 8-bit groups:
	// (w + w&gt;&gt;4) &amp; 00001111,00001111 = 00000100,00000100
	w += w &gt;&gt; 4
	w &amp;= maxw / 255 * 15

	// Add all 8-bit counts with a multiplication and a shift:
	// (w * 00000001,00000001) &gt;&gt; 8 = 00001000
	w *= maxw / 255
	w &gt;&gt;= (bpw/8 - 1) * 8
	return int(w)
}
</code></pre>

<p><em>Source code from <a href="https://github.com/yourbasic/bit/blob/master/funcs.go">funcs.go</a>.</em></p>

<p>As of Go 1.9 a bit count function is available in the new package <code>math/bits</code>.
On most architectures functions in this package are recognized
by the compiler and treated as intrinsics for additional performance.</p>

<h3 id="fast-sorting">Fast sorting</h3>

<p><a href="https://github.com/yourbasic/radix">Radix sort</a> also uses bit manipulation to good effect.
For string sorting, a carefully implemented radix sort can be
considerably faster than Quicksort, sometimes more than twice as fast.
A discussion of <strong>MSD radix sort</strong>, its implementation and a comparison
with other well-known sorting algorithms can be found in
<a href="https://www.nada.kth.se/~snilsson/publications/Radixsort-implementation/">Implementing radixsort</a>.</p>

<p>Bitwise operators are also crucial in the implementation of the fastest
known integer sorting algorithm. It sorts <em>n</em> integers
in O(<em>n</em> log log <em>n</em>) worst-case time on a unit-cost RAM machine,
the standard computational model in theoretical computer science.
<a href="https://www.nada.kth.se/~snilsson/fast-sorting/">The fastest sorting algorithm?</a> has all the details.</p>

<h2 id="simple-sets">Simple sets</h2>

<p>A <a href="https://en.wikipedia.org/wiki/Bit_array">bit set</a>, or bit array, must be the simplest
data structure in town. It&rsquo;s just an array of integers, where the bit
at position <em>k</em> is one whenever <em>k</em> belongs to the set.</p>

<p>Even though it&rsquo;s simple, a bit set can be quite powerful. Because it uses
bit-level parallelism, limits memory access, and plays nicely with
the data cache, it tends to be very efficient and often outperforms other
set data structures.</p>

<p>Memory consumption isn&rsquo;t too shabby either. If you have a gigabyte
of RAM to spare, you can story a set of integer elements in the range
0 to 8,589,934,591.</p>

<h3 id="sieve-of-eratosthenes">Sieve of Eratosthenes</h3>

<p><img src="/algorithms/eratosthenes.png" alt="Eratosthenes" /></p>

<p><strong>Eratosthenes of Cyrene</strong> <!-- *276-194 BC, image from [Wikipedia][eratosthenes] --></p>

<p>This code snippet implements the sieve of Eratosthenes
(with an optimization suggested by <a href="https://gmplib.org/~tege/">tege</a>).
It uses a bit set implementation from the <a href="https://github.com/yourbasic/bit">bit</a> package
to generate the set of all primes less than <em>n</em> in O(<em>n</em> log log <em>n</em>) time.
Try it with <em>n</em> equal to a few hundred millions and be pleasantly surprised.</p>

<pre><code class="language-go">sieve := bit.New().AddRange(2, n)
for k := 4; k &lt; n; k += 2 {
    sieve.Delete(k)
}
sqrtN := int(math.Sqrt(n))
for p := 3; p &lt;= sqrtN; p = sieve.Next(p) {
	for k := p * p; k &lt; n; k += 2 * p {
		sieve.Delete(k)
	}
}
</code></pre>

<h3 id="a-fly-in-the-ointment">A fly in the ointment</h3>

<p>The code above doesn&rsquo;t guard against <a href="https://en.wikipedia.org/wiki/Integer_overflow">integer overflow</a>.
If <em>n</em> is too close to the maximum representable value of an <code>int</code>,
the index variable <em>k</em> will eventually wrap around and become negative.</p>

<h2 id="efficient-filtering">Efficient filtering</h2>

<p><a href="https://en.wikipedia.org/wiki/Hash_function">Hash functions</a> are yet another triumph for the integer data type.
They are worth a tribute of their own, but in this section we will
just take them for granted. If we combine a bit array with
a set of hash functions we get a <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>, a probabilistic
data structure used to test set membership.</p>

<p>This data structure tells whether an element <strong>may be</strong> in a set, or <strong>definitely isn&rsquo;t</strong>.
The only possible errors are <em>false positives</em>: a search for a nonexistent element
can give an incorrect answer.
With more elements in the filter, the error rate increases.</p>

<p>Bloom filters are both <em>fast</em> and <em>space-efficient</em>. However, elements can only be added, not removed.</p>

<p>Content distribution networks use them to avoid caching one-hit wonders, files that are seen only once. Web browsers use them to check for potentially harmful URLs.</p>

<h3 id="a-blacklist-of-shady-websites">A blacklist of shady websites</h3>

<p>This piece of code, from the Go package <a href="https://godoc.org/github.com/yourbasic/bloom">bloom</a>,
shows a typical Bloom filter use case.</p>

<pre><code><span class="comment">// A Bloom filter with room for at most 100000 elements.
// The error rate for the filter is less than 1/200.</span>
blacklist := bloom.New(10000, 200)

<span class="comment">// Add an element to the filter.</span>
url := "https://rascal.com"
blacklist.Add(url) 

<span class="comment">// Test for membership.</span>
if blacklist.Test(url) {
    fmt.Println(url, "may be blacklisted.")
} else {
    fmt.Println(url, "has not been added to our blacklist.")
}</code></pre>

<pre><code>https://rascal.com may be blacklisted.</code></pre>

<h3 id="bloom-filter-implementation">Bloom filter implementation</h3>

<p>An empty Bloom filter is a bit array of <i>m</i>&nbsp;bits, all set to&nbsp;0.
There are also <i>k</i>&nbsp;different hash functions,
each of which maps a set element to one of the&nbsp;<i>m</i> bit positions.</p>

<ul>
<li>To add an element, feed it to the hash functions to&nbsp;get <i>k</i> bit positions,
and&nbsp;set the&nbsp;bits at these positions to&nbsp;1.</li>
<li>To test if an element is in the&nbsp;set, feed it to the&nbsp;hash functions to&nbsp;get <i>k</i> bit positions.

<ul>
<li>If any of the&nbsp;bits at these positions is&nbsp;0, the&nbsp;element
<strong>definitely isn&rsquo;t</strong> the&nbsp;set.</li>
<li>If all are&nbsp;1, then the&nbsp;element <strong>may be</strong> in the&nbsp;set.</li>
</ul></li>
</ul>

<h3 id="example">Example</h3>

<p>Here is a Bloom filter with three elements <i>x</i>, <i>y </i> and <i>z</i>.
It consists of 18&nbsp;bits and uses 3&nbsp;hash functions.
The colored arrows point to the bits that the elements of the set are mapped&nbsp;to.</p>

<!-- Public domain: https://en.wikipedia.org/wiki/File:Bloom_filter.svg -->

<p><img src="/algorithms/bloom-filter.svg" style="width:500px;" alt="Bloom filter"></p>

<p>The&nbsp;element <i>w</i> definitely isn&rsquo;t in the&nbsp;set, since it hashes to a bit position containing&nbsp;0.</p>

<!-- Example from [Wikipedia][wikibloompic]. -->

<p>The colored arrows point to the bits that the elements
of the set {<em>x</em>, <em>y</em>, <em>z</em>} are mapped to. The element <em>w</em> is not in the set,
because it hashes to a bit position containing 0.</p>

<p><b>Share this article:</b>
    <a href="https://twitter.com/share?url=http%3a%2f%2fyourbasic.org%2falgorithms%2fyour-basic-int%2f&amp;text=Your%20basic%20int:%20a%20most%20powerful%20data%20type">Twitter</a>&nbsp;|
    <a href="https://www.facebook.com/sharer.php?u=http%3a%2f%2fyourbasic.org%2falgorithms%2fyour-basic-int%2f">Facebook</a>&nbsp;|
    <a href="mailto:?subject=Article:%20Your%20basic%20int:%20a%20most%20powerful%20data%20type&amp;body=http%3a%2f%2fyourbasic.org%2falgorithms%2fyour-basic-int%2f">Email</a></p>
</article>
<aside>

  <h2>Related</h2>

  <div class="reference">
    <a href="/algorithms/bloom-filter/">Bloom filters</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <div class="reference">
    <a href="/algorithms/hash-tables-explained/">Hash tables</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <h2>Top algorithm articles</h2>
  <ul class="none">
  
    <li><a href="/algorithms/your-basic-api/">Your basic API</a></li>

    <li><a href="/algorithms/hash-tables-explained/">Hash tables</a></li>

    <li><a href="/algorithms/big-o-notation-explained/">Big O notation</a></li>

    <li><a href="/algorithms/loop-invariants-explained/">Loop invariants</a></li>

    <li><a href="/golang/quicksort-optimizations/">Top 3 Quicksort optimizations</a></li>

  </ul>

  <p><a href="/algorithms/"><b>See all algorithm articles</b></a></p>
</aside>
</main>

<footer>
  This work is licensed under&nbsp;a&nbsp;<a rel="license" alt="CC BY 3.0"
  href="http://creativecommons.org/licenses/by/3.0/"><span
  style="font-size:smaller;">CC&nbsp;BY&nbsp;3.0</span>&nbsp;license</a>.
</footer>
</body>
</html>
