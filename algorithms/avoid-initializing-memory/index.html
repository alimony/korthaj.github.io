<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How to avoid initializing memory | yourbasic.org </title>
  <meta name="description" content="If the running time is smaller than the size of the memory, it&#39;s possible to refrain from initializing the memory and still get the same asymptotic time complexity.">
  
  <link rel="stylesheet" href="/style.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="icon" type="image/png" href="/res/favicon-16x16.png">
  <link rel="icon" type="image/png" href="/res/favicon-32x32.png">
  <link rel="icon" type="image/png" href="/res/favicon-96x96.png">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113104149-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113104149-1');
  </script>

</head>

<body>
<header>
  <nav>
    <ul>
      <li><a href="/about/">About</a></li>
      <li><a href="/">Home</a></li>
      <li><a href="/algorithms/">Algorithms</a></li>
      <li><a href="/golang/">Go</a></li>
    </ul>
  </nav>
</header>

<main>
<article>
<h1>How to avoid initializing memory</h1>
<div class="tagline">yourbasic.org</div>
<p>
Consider an algorithm that uses a large memory area.
If the running time of the algorithm is smaller than the size of the memory,
initializing the memory will take longer than running the algorithm.
However, using a shrewd trick,
it’s possible to refrain from initializing the&nbsp;memory.
</p>

<p>
The idea is to keep track of which memory positions have been used so far.
Using this information, you may postpone the initialization until
the first time a memory cell is encountered.
</p>

<p>
One solution would be to use an array to keep track of active memory positions.
Every time a memory position is accessed,
check whether the address is in this array of active memory positions.
If not, initialize this memory cell and add the address to the&nbsp;array.
</p>

<p>
For this scheme to work without increasing the overall running time,
it’s crucial that the lookups in the array can be performed in constant time.
To achieve this, use double bookkeeping.
Not only do you use an array of active memory positions,
but each memory position is also extended to contain a pointer into this array.
In this figure, for instance, the memory has three active memory cells:
cell numbers 0, 4, and&nbsp;6.
</p>

<pre>
Memory                         Active
-------------------------      -------
Address Contents Pointer

0       134431   X---------->  0
1       938434      -------->  4
2       432754      |  ----->  6
3       292343      |  |
4       874944   X---  |
5       002345         |
6       654243   X------
7       112903
</pre>

<p>
Checking whether a memory cell is active is a two-step procedure.
First, you check whether the pointer attached to this memory position is valid:
Does it point to a position in the active array?
If not, the memory position contains garbage and has not been initialized.
If the pointer is valid, you also need to check whether the corresponding pointe
in the active array actually points to this memory address.
If it does, the memory cell is active.
</p>

<p>
This check only requires two memory accesses.
Hence, it can be performed in constant time.
Adding a new address to the active list is also done in constant time:
Store the memory address in the next free position in the active array and
set up the pointer associated with the memory location accordingly.
</p>


</article>
<aside>

  <h2>Related</h2>

  <div class="reference">
    <a href="/algorithms/fastest-sorting-algorithm/">The fastest sorting algorithm?</a><br />
    <span class="source">yourbasic.org</span>
  </div>

  <h2>Top algorithm articles</h2>
  <ul class="none">
  
    <li><a href="/algorithms/your-basic-api/">Your basic API</a></li>

    <li><a href="/algorithms/hash-tables-explained/">Hash tables</a></li>

    <li><a href="/algorithms/big-o-notation-explained/">Big O notation</a></li>

    <li><a href="/algorithms/loop-invariants-explained/">Loop invariants</a></li>

    <li><a href="/golang/quicksort-optimizations/">Top 3 Quicksort optimizations</a></li>

  </ul>

  <p><a href="/algorithms/"><b>See all algorithm articles</b></a></p>
</aside>
</main>

<footer>
  This work is licensed under&nbsp;a&nbsp;<a rel="license" alt="CC BY 3.0"
  href="http://creativecommons.org/licenses/by/3.0/"><span
  style="font-size:smaller;">CC&nbsp;BY&nbsp;3.0</span>&nbsp;license</a>.
</footer>
</body>
</html>
